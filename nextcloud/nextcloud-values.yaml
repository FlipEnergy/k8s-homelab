# Override values for Nextcloud

image:
  repository: nextcloud

## Allowing use of ingress controllers
## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
##
ingress:
  enabled: true
  annotations:
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-body-size: 20G
    nginx.ingress.kubernetes.io/server-snippet: |-
      server_tokens off;
      proxy_hide_header X-Powered-By;

      rewrite ^/.well-known/webfinger /public.php?service=webfinger last;
      rewrite ^/.well-known/host-meta /public.php?service=host-meta last;
      rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json;
      location = /.well-known/carddav {
        return 301 $scheme://$host/remote.php/dav;
      }
      location = /.well-known/caldav {
        return 301 $scheme://$host/remote.php/dav;
      }
      location = /robots.txt {
        allow all;
        log_not_found off;
        access_log off;
      }
      location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/ {
        deny all;
      }
      location ~ ^/(?:autotest|occ|issue|indie|db_|console) {
        deny all;
      }

securityContext:
  runAsUser: 1000
  runAsNonRoot: true

nextcloud:
  host: cloud.pleasenoddos.com
  containerPort: 8080

  mail:
    enabled: true
    fromAddress: dennis.zhang.nrg
    domain: gmail.com
    smtp:
      host: smtp.gmail.com
      secure: tls
      port: 587
      authtype: LOGIN

  # Extra mounts for the pods. Example shown is for connecting a legacy NFS volume
  # to NextCloud pods in Kubernetes. This can then be configured in External Storage
  extraVolumes:
    - name: apache-conf
      configMap:
        name: nextcloud-apache2-conf
  extraVolumeMounts:
    - name: apache-conf
      mountPath: /etc/apache2/ports.conf
      subPath: ports.conf
      readOnly: true
    - name: apache-conf
      mountPath: /etc/apache2/sites-enabled/000-default.conf
      subPath: 000-default.conf
      readOnly: true

  ##
  ## Extra environment variables
  extraEnv:
    - name: OVERWRITEPROTOCOL
      value: https

internalDatabase:
  enabled: false

##
## External database configuration
##
externalDatabase:
  enabled: true
  ## Supported database engines: mysql or postgresql
  type: postgresql
  ## Database host
  host: postgresql.postgresql
  ## Database name
  database: nextcloud

## Cronjob to execute Nextcloud background tasks
## ref: https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/background_jobs_configuration.html#webcron
##
cronjob:
  enabled: true
  # Every 5 minutes
  # Note: Setting this to any any other value than 5 minutes might
  #  cause issues with how nextcloud background jobs are executed
  schedule: "*/5 * * * *"
  annotations: {}
  failedJobsHistoryLimit: 0
  successfulJobsHistoryLimit: 1
  resources:
    limits:
      cpu: 50m
      memory: 10Mi
    requests:
      cpu: 50m
      memory: 10Mi

## Enable persistence using Persistent Volume Claims
## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
##
persistence:
  # Nextcloud Data (/var/www/html)
  enabled: true
  annotations: {}
  # nextcloud data Persistent Volume Storage Class
  # If defined, storageClassName: <storageClass>
  # If set to "-", storageClassName: "", which disables dynamic provisioning
  # If undefined (the default) or set to null, no storageClassName spec is
  #   set, choosing the default provisioner.  (gp2 on AWS, standard on
  #   GKE, AWS & OpenStack)
  #
  storageClass: nextcloud-data

  ## A manually managed Persistent Volume and Claim
  ## Requires persistence.enabled: true
  ## If defined, PVC must be created manually before volume will be bound
  # existingClaim:

  accessMode: ReadWriteOnce
  size: 3Ti

resources:
  limits:
    cpu: 2
    memory: 3Gi
  requests:
    cpu: 2
    memory: 1Gi

nodeSelector:
  kubernetes.io/arch: amd64
  performance: medium
  type: app

tolerations: []

affinity: {}
  # podAntiAffinity:
  #   preferredDuringSchedulingIgnoredDuringExecution:
  #   - weight: 100
  #     podAffinityTerm:
  #       labelSelector:
  #         matchExpressions:
  #         - key: app.kubernetes.io/name
  #           operator: In
  #           values:
  #             - postgresql
  #       topologyKey: kubernetes.io/hostname

## Liveness and readiness probe values
## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
##
livenessProbe:
  enabled: true
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 10
  failureThreshold: 6
  successThreshold: 1
readinessProbe:
  enabled: true
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 10
  failureThreshold: 6
  successThreshold: 1
startupProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 60
  successThreshold: 1

##
## Redis chart configuration
## for more options see https://github.com/bitnami/charts/tree/master/bitnami/redis
##

redis:
  enabled: true
  ## @param architecture Redis&trade; architecture. Allowed values: `standalone` or `replication`
  ##
  architecture: standalone
  auth:
    enabled: true
  master:
    resources:
      limits:
        cpu: 1
        memory: 3Gi
      requests:
        cpu: 1
        memory: 3Gi
    nodeSelector:
      kubernetes.io/arch: amd64
      performance: medium
      type: app
  replica:
    replicaCount: 0
